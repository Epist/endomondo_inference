#For recommending workouts with a desired target sequence attribute

#Compute the AUC

#User chooses a workout that they want to find a similar heart rate profile for
#Choose x workouts at random
#Compute the "distances" between the heart rates generated by the model for each of these x workouts and the target heart rate sequence
#Rank the x workouts in order of best fit to target (lowest distance)
#Find the rank of the original workout in this list
#Return the list of workout numbers and their corresponding similarity scores in order


from __future__ import print_function
from __future__ import absolute_import
from __future__ import division

import keras
from keras.models import Sequential
from keras.layers import Dense, Activation, Dropout
from keras.layers import LSTM
from keras.layers.core import Reshape
from keras.utils.data_utils import get_file
from keras.callbacks import ModelCheckpoint, EarlyStopping
import numpy as np
import random
import sys, argparse

#from data_interpreter_Keras import dataInterpreter, metaDataEndomondo
from data_interpreter_Keras_multiTarget import dataInterpreter, metaDataEndomondo
from inputManager import inputManager
import pickle
from math import floor
import matplotlib
#matplotlib.use('agg')
import matplotlib.pyplot as plt
import time
import datetime
from parse_args_keras import parse_args_keras
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
import random

#Params
#target_workout_index = 3 #1234 #Choose a workout to use as the target heart rate!!!
number_to_search = 100
number_of_target_tests = 100
#target_variable = "heart_rate" #Can only use a single target variable
distance_metric = "MAE"
#modelFN = "model_states/keras__all_hrTarget_noTarScaling08_28PM_March_21_2017_bestValidScore" # "model_states/keras__all08_06PM_March_19_2017_bestValidScore"
#modelFN = "model_states/keras__all_speedTarget_noTarScaling06_26PM_March_21_2017_bestValidScore"
#modelFN = "model_states/keras__all08_06PM_March_19_2017_bestValidScore"
modelFN = "model_states/keras__all_hrTarget_noTarScaling08_28PM_March_21_2017_bestValidScore"

data_path = "../multimodalDBM/endomondoHR_proper_newmeta_copy.json" # "../multimodalDBM/endomondoHR_proper_copy.json"
endoFeatures = ["heart_rate", "new_workout", "gender", "sport", "userId", "altitude", "distance", "derived_speed", "time_elapsed"]
targetAtts = ["heart_rate"]
trimmed_workout_len = 450
scale_toggle = True
scaleTargets= False #"scaleVals" #False
zMultiple = 5
endoReader = dataInterpreter(fn=data_path, scaleVals=scale_toggle, trimmed_workout_length=trimmed_workout_len, scaleTargets=scaleTargets)
endoReader.buildDataSchema(endoFeatures, targetAtts, zMultiple = zMultiple)

#if target_workout_index not in endoReader.dataPointList:
#	raise(exception("The target workout is in the excised list!!! Choose another..."))


class workout(object):
	def __init__(self, workoutIndex):
		self.workoutIndex = workoutIndex
		self.inputSeq = None
		self.targetSeq = None
		self.rawInputSeq = None
		self.rawTargetSeq = None
		self.loadData()
		self.predictedTrace = None
		self.evalScore = None

	def loadData(self):
		#Load the inputs and targets from the json file and scale them appropriately
		(xr, yr) = endoReader.getDpByIndex(self.workoutIndex, scaling=False)
		self.rawInputSeq = xr
		self.rawTargetSeq = yr

		(x, y) = endoReader.getDpByIndex(self.workoutIndex, scaling=True)
		self.inputSeq = x
		self.targetSeq = y
 

def predict_model(model, inputSeq):
	return model.predict_on_batch(inputSeq)

def eval_model(predictedTrace, targetSeq, distance_metric):
	#return model.test_on_batch(targetSeq)
	if distance_metric == "MSE":
		return mean_squared_error(predictedTrace, targetSeq)
	if distance_metric == "MAE":
		return mean_absolute_error(predictedTrace, targetSeq)

#def eval_model_interp(predictedTrace, targetSeq, testTimes, targetTimes, rate):
	#Takes in the heart rate traces from the prediction and the target as well as the elapsed time sequences for both 
	#and interpolates and resamples them so that they share a time axis (using the rate paramater to define the steps in the time sequence)
	#Then it computes the distance between the two series'


availableWorkouts = endoReader.dataPointList

def genRandomWorkoutList(numWorkouts, availableWorkouts):
	#From the available workouts, select numWorkouts, generate the workout objects, and add them to a list
	random.shuffle(availableWorkouts)
	wo_indices = availableWorkouts[0:numWorkouts]
	return [workout(x) for x in wo_indices]

def workoutFitCompare(wo1, wo2):
	if wo1.evalScore>wo2.evalScore:
		return -1 #The second workout has lower error and therefore should come first
	elif wo1.evalScore<wo2.evalScore:
		return 1 #The first workout has lower error and therefore should come first
	else:
		return 0

def findTargetRank(sortedWOList, target_workout_index):
	for i, wo in enumerate(sortedWOList):
		if wo.workoutIndex == target_workout_index:
			return i+1 #Rank is indexed from 1
	raise(exception("Target workout not in the list"))

#Load a trained model
def load_and_rebuild_model(modelFN, num_steps, input_dim, target_dim):
	oldModel = keras.models.load_model(modelFN)#Load a model that has already been trained

	print('Build model...')
	model = Sequential()
	#model.add(Reshape((batch_size_m, num_steps, input_dim), batch_input_shape=(batch_size_m*num_steps, input_dim)))
	model.add(LSTM(128, return_sequences=True, batch_input_shape=(1, num_steps, input_dim), stateful=True))
	model.add(Dropout(0.2))
	model.add(LSTM(128, return_sequences=True, stateful=True))
	model.add(Dropout(0.2))
	model.add(Dense(target_dim))
	model.add(Activation('linear'))

	model.compile(loss='mean_squared_error', optimizer='rmsprop')

	model.set_weights(oldModel.get_weights())#Transfer the weights from the old model to the new model
	print("Endomodel Built!")

	return model

model = load_and_rebuild_model(modelFN, trimmed_workout_len, endoReader.getInputDim(targetAtts), endoReader.getTargetDim(targetAtts))

print("Model filename: " + modelFN)
print("Distance metric: " + distance_metric)

target_ranks = []
for i in range(number_of_target_tests):
	print("  Computed " + str(i) + " target AUCs so far")
	#Generate the list of random workouts
	workoutList = genRandomWorkoutList(number_to_search, availableWorkouts)

	#Get random target workout
	targetWorkout = random.choice(workoutList)
	target_workout_index = targetWorkout.workoutIndex

	#workoutList.append(targetWorkout)

	#Compute the predicted heart rate sequences on each workout in the list
	print("    Predicting workouts")
	for j, wo in enumerate(workoutList):
		#if j%100==0:
		#	print("Predicted " + str(j) + " workouts so far")
		inputSeq = wo.inputSeq
		targetSeq = targetWorkout.targetSeq
		predictedTrace = predict_model(model, inputSeq)
		#Compute the similarity for each heart rate sequence (Could do this by using the target HR seq as the target seq in the model)
		eval_score = eval_model(predictedTrace[0,:,:], targetSeq[0,:,:], distance_metric)
		wo.predictedTrace = predictedTrace
		wo.evalScore = eval_score

	#Sort the list of workouts by similarityScore
	#Impliment a custom comparator for workout objects. Then use a library quicksort to sort the list
	print("    Sorting workouts")
	#workoutList.sort(workoutFitCompare)
	workoutList.sort(key=lambda x: x.evalScore)

	#Find the position of the targetWorkout in the sorted list of workouts


	targetRank = findTargetRank(workoutList, target_workout_index)
	target_ranks.append(targetRank)
	print("    Target rank: " + str(targetRank) + " out of " + str(number_to_search))
	#print("    Target " + distance_metric + " is " + str(workoutList[targetRank-1].evalScore))
	#print("    Best " + distance_metric + " is " + str(workoutList[0].evalScore))
	#print("    Worst " + distance_metric + " is " + str(workoutList[number_to_search].evalScore))

average_target_rank = np.mean(target_ranks)
print("The average target rank for " + str(number_of_target_tests) + " random targets and " + str(number_to_search) + " comaprisons per target is " + str(average_target_rank))
print("The AUC is " + str(1-(average_target_rank/number_to_search)))

#Save the ordered list of workouts as well as the targetWorkout and the paramaters 


#Provide tools for visualizing the matches

