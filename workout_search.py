#For recommending workouts with a desired target sequence attribute

#Compute the AUC

#User chooses a workout that they want to find a similar heart rate profile for
#Choose x workouts at random
#Compute the "distances" between the heart rates generated by the model for each of these x workouts and the target heart rate sequence
#Rank the x workouts in order of best fit to target (lowest distance)
#Find the rank of the original workout in this list
#Return the list of workout numbers and their corresponding similarity scores in order


from __future__ import print_function
from __future__ import absolute_import
from __future__ import division

import keras
from keras.models import Sequential
from keras.layers import Dense, Activation, Dropout
from keras.layers import LSTM
from keras.layers.core import Reshape
from keras.utils.data_utils import get_file
from keras.callbacks import ModelCheckpoint, EarlyStopping
import numpy as np
import random
import sys, argparse

#from data_interpreter_Keras import dataInterpreter, metaDataEndomondo
from data_interpreter_Keras_multiTarget import dataInterpreter, metaDataEndomondo
from inputManager import inputManager
import pickle
from math import floor
import matplotlib
#matplotlib.use('agg')
import matplotlib.pyplot as plt
import time
import datetime
from parse_args_keras import parse_args_keras
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error

#Params
target_workout_index = 93082 #1234 #Choose a workout to use as the target heart rate!!!
number_to_search = 9999
target_variable = "heart_rate" #Can only use a single target variable
distance_metric = "MAE"
modelFN = "model_states/keras__all_hrTarget_noTarScaling08_28PM_March_21_2017_bestValidScore" #keras__noAltitude02_49AM_March_16_2017_epoch_25



data_path = "../multimodalDBM/endomondoHR_proper_newmeta.json"
#endoFeatures = ["sport", "heart_rate", "gender", "altitude", "time_elapsed", "distance", "new_workout", "derived_speed", "userId"]
endoFeatures = ["heart_rate", "new_workout", "gender", "sport", "userId", "altitude", "distance", "derived_speed", "time_elapsed"]
targetAtts = ["heart_rate"]
trimmed_workout_len = 450
scale_toggle = True
scaleTargets= False #"scaleVals" #False
zMultiple = 5
endoReader = dataInterpreter(fn=data_path, scaleVals=scale_toggle, trimmed_workout_length=trimmed_workout_len, scaleTargets=scaleTargets)
endoReader.buildDataSchema(endoFeatures, targetAtts, zMultiple = zMultiple)

if target_workout_index not in endoReader.dataPointList:
	raise(exception("The target workout is in the excised list!!! Choose another..."))


class workout(object):
	def __init__(self, workoutIndex):
		self.workoutIndex = workoutIndex
		self.inputSeq = None
		self.targetSeq = None
		self.rawInputSeq = None
		self.rawTargetSeq = None
		self.loadData()
		self.predictedTrace = None
		self.evalScore = None

	def loadData(self):
		#Load the inputs and targets from the json file and scale them appropriately
		(xr, yr) = endoReader.getDpByIndex(self.workoutIndex, scaling=False)
		self.rawInputSeq = xr
		self.rawTargetSeq = yr

		(x, y) = endoReader.getDpByIndex(self.workoutIndex, scaling=True)
		self.inputSeq = x
		self.targetSeq = y
 

def predict_model(model, inputSeq):
	return model.predict_on_batch(inputSeq)

def eval_model(predictedTrace, targetSeq, distance_metric):
	#return model.test_on_batch(targetSeq)
	if distance_metric == "MSE":
		return mean_squared_error(predictedTrace, targetSeq)
	if distance_metric == "MAE":
		return mean_absolute_error(predictedTrace, targetSeq)


availableWorkouts = [x for x in endoReader.dataPointList if x != target_workout_index]

def genRandomWorkoutList(numWorkouts, availableWorkouts):
	#From the available workouts, select numWorkouts, generate the workout objects, and add them to a list
	random.shuffle(availableWorkouts)
	wo_indices = availableWorkouts[0:numWorkouts]
	return [workout(x) for x in wo_indices]

def workoutFitCompare(wo1, wo2):
	if wo1.evalScore>wo2.evalScore:
		return -1 #The second workout has lower error and therefore should come first
	elif wo1.evalScore<wo2.evalScore:
		return 1 #The first workout has lower error and therefore should come first
	else:
		return 0

#Generate the list of random workouts
workoutList = genRandomWorkoutList(number_to_search, availableWorkouts)

#Add the target workout to the list of random workouts
targetWorkout = workout(target_workout_index)
workoutList.append(targetWorkout)

#Load a trained model
def load_and_rebuild_model(modelFN, num_steps, input_dim, target_dim):
	oldModel = keras.models.load_model(modelFN)#Load a model that has already been trained

	print('Build model...')
	model = Sequential()
	#model.add(Reshape((batch_size_m, num_steps, input_dim), batch_input_shape=(batch_size_m*num_steps, input_dim)))
	model.add(LSTM(128, return_sequences=True, batch_input_shape=(1, num_steps, input_dim), stateful=True))
	model.add(Dropout(0.2))
	model.add(LSTM(128, return_sequences=True, stateful=True))
	model.add(Dropout(0.2))
	model.add(Dense(target_dim))
	model.add(Activation('linear'))

	model.compile(loss='mean_squared_error', optimizer='rmsprop')

	model.set_weights(oldModel.get_weights())#Transfer the weights from the old model to the new model
	print("Endomodel Built!")

	return model

model = load_and_rebuild_model(modelFN, trimmed_workout_len, endoReader.getInputDim(targetAtts), endoReader.getTargetDim(targetAtts))

#Compute the predicted heart rate sequences on each workout in the list
print("Predicting workouts")
for i, wo in enumerate(workoutList):
	if i%100==0:
		print("Predicted " + str(i) + " workouts so far")
	inputSeq = wo.inputSeq
	targetSeq = targetWorkout.targetSeq
	predictedTrace = predict_model(model, inputSeq)
	#Compute the similarity for each heart rate sequence (Could do this by using the target HR seq as the target seq in the model)
	eval_score = eval_model(predictedTrace[0,:,:], targetSeq[0,:,:], distance_metric)
	wo.predictedTrace = predictedTrace
	wo.evalScore = eval_score

#Sort the list of workouts by similarityScore
#Impliment a custom comparator for workout objects. Then use a library quicksort to sort the list
print("Sorting workouts")
#workoutList.sort(workoutFitCompare)
workoutList.sort(key=lambda x: x.evalScore)

#Find the position of the targetWorkout in the sorted list of workouts
def findTargetRank(sortedWOList, target_workout_index):
	for i, wo in enumerate(sortedWOList):
		if wo.workoutIndex == target_workout_index:
			return i+1 #Rank is indexed from 1
	raise(exception("Target workout not in the list"))

targetRank = findTargetRank(workoutList, target_workout_index)
print("Target rank: " + str(targetRank) + " out of " + str(number_to_search+1))
print("Target " + distance_metric + " is " + str(workoutList[targetRank-1].evalScore))
print("Best " + distance_metric + " is " + str(workoutList[0].evalScore))
print("Worst " + distance_metric + " is " + str(workoutList[number_to_search].evalScore))
print("The AUC is " + str(1-(targetRank/number_to_search)))

print("The indices of the top 10 workouts are: ", [wo.workoutIndex for wo in sortedWOList[0:10]])

#Save the ordered list of workouts as well as the targetWorkout and the paramaters 


#Provide tools for visualizing the matches

